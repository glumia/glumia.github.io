<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on glumia's blog</title><link>https://glumia.dev/blog/</link><description>Recent content in Blog on glumia's blog</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Sun, 24 Apr 2022 17:32:09 +0200</lastBuildDate><atom:link href="https://glumia.dev/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Bite Size Linux</title><link>https://glumia.dev/blog/bite-size-linux/</link><pubDate>Sun, 24 Apr 2022 17:32:09 +0200</pubDate><guid>https://glumia.dev/blog/bite-size-linux/</guid><description>The following are some notes about questions that came to my mind while reading Julia Evans' (awesome) zine Bite Size Linux.
What are the setuid, setgid and sticky bits of a file?
What&amp;rsquo;s inside /proc/PID/stack?
Why would I want to use mkfifo? (named pipes)
What are Unix domain sockets and why would I want to use them?
Can I see a process' registered signal handlers from /proc/PID?
What is a memory allocator?</description></item><item><title>Random thoughts on Software Engineering and Science</title><link>https://glumia.dev/blog/random-thoughts-on-software-engineering-and-science/</link><pubDate>Fri, 23 Jul 2021 19:06:35 +0200</pubDate><guid>https://glumia.dev/blog/random-thoughts-on-software-engineering-and-science/</guid><description>The other day I was randomly reading some stuff on lobste.rs, when I found this post &amp;ldquo;What I learned from Software Engineering at Google&amp;rdquo;. As I usually do, I skimmed through the comments and decided to stop there - more often than not it&amp;rsquo;s enough information to decide if a full read is worth it or not. I know, that&amp;rsquo;s not an infallible heuristic, but our time in this world is limited and I can&amp;rsquo;t keep up with everything that&amp;rsquo;s on the web, even if I would like to.</description></item><item><title>Codility - Part 1 (and probably last, until I'll get back to job hunting)</title><link>https://glumia.dev/blog/codility-part-1-and-probably-last-until-ill-get-back-to-job-hunting/</link><pubDate>Sat, 03 Apr 2021 13:17:05 +0200</pubDate><guid>https://glumia.dev/blog/codility-part-1-and-probably-last-until-ill-get-back-to-job-hunting/</guid><description>Lately I&amp;rsquo;ve been looking for materials to practice for code interviews and a friend of mine pointed out Codility&amp;rsquo;s lessons to me. Their web site and application are still a bit in the early stages (imho they are not as mature as other sites like HackerRank or CodinGame) but one really nice thing that the others lack is the reading material they provide for each topic.
I plan to go through the lessons (at least 1 to 17) in the following days/weeks and I&amp;rsquo;ll write random thoughts that arise while working on them here in the blog.</description></item><item><title>Clojure, Python, C: three programming languages, one algorithm</title><link>https://glumia.dev/blog/clojure-python-c-three-programming-languages-one-algorithm/</link><pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate><guid>https://glumia.dev/blog/clojure-python-c-three-programming-languages-one-algorithm/</guid><description>Too lazy to write something long and well thought now ¯\_(ツ)_/¯
Just a bit disappointed by how bad Clojure&amp;rsquo;s performance are (but hey, immutability is not free!) and by how damn difficult it is to improve them.
Update 23/06/20 I found out that the timing of the C version goes down to ~2ms if I just declare the variables as int and not unsigned int. That&amp;rsquo;s amazing!
Update 09/01/21 Half I year later I finally know why the version with signed integers actually takes less than the version with unsigned ints.</description></item><item><title>The Levenshtein Distance</title><link>https://glumia.dev/blog/the-levenshtein-distance/</link><pubDate>Fri, 03 Jan 2020 00:00:00 +0000</pubDate><guid>https://glumia.dev/blog/the-levenshtein-distance/</guid><description>It&amp;rsquo;s fascinating how every problem you can think of in computer science 9 times out of 10 was already tackled and solved by someone else. Today I was thinking about a way to suggest corrections for addresses inserted by our customers when I started to imagine an algorithm that used the mathematical notion of &amp;lsquo;distance&amp;rsquo; (check &amp;lsquo;Metric (mathematics)&amp;rsquo; on Wikipedia 1 ) to give them some suggestions based on a set of valid addresses present on our DB.</description></item><item><title>C and Assembly - Subtleties</title><link>https://glumia.dev/blog/c-and-assembly-subtleties/</link><pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate><guid>https://glumia.dev/blog/c-and-assembly-subtleties/</guid><description>Should I write this int flag = 0; // Boolean value, can only be 0 or 1 while(some_condition){ // … if(flag == 0) flag = 1; // … } or int flag = 0; while(some_condition){ // … flag = 1; // … } what performs better? While I was writing some C code I came up to this little question. In a while loop at a certain point we have to set a boolean flag&amp;rsquo;s value to 1.</description></item><item><title>GOG Store - Overkill search</title><link>https://glumia.dev/blog/gog-store-overkill-search/</link><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><guid>https://glumia.dev/blog/gog-store-overkill-search/</guid><description>I had 1.30 euro remaining on my GOG wallet and I had to use them before Sept. 19 or they would expire. I started to look for a game but store&amp;rsquo;s search engine didn&amp;rsquo;t allow me to filter them for a price in a custom range. I could only search for games whose price was less than 5 euros, and this still yield to 530 results. Too many to check them one by one.</description></item></channel></rss>